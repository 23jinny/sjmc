<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction to Multi-Group Cross Sections (MGXS) &mdash; OpenMC Documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="OpenMC Documentation" href="../../index.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner">
        <a href="../../index.html">
          <img class="logo" src="../../_static/openmc.png" alt="Logo"/>
        </a>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <p>This IPython Notebook introduces the use of the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> module
to calculate multi-group cross sections for an infinite homogeneous
medium. In particular, this Notebook introduces the the following
features:</p>
<ul class="simple">
<li><strong>General equations</strong> for scalar-flux averaged multi-group cross
sections</li>
<li>Creation of multi-group cross sections for an <strong>infinite homogeneous
medium</strong></li>
<li>Use of <strong>tally arithmetic</strong> to manipulate multi-group cross sections</li>
</ul>
<p><strong>Note:</strong> This Notebook illustrates the use of
<a class="reference external" href="http://pandas.pydata.org/">Pandas</a> <code class="docutils literal"><span class="pre">DataFrames</span></code> to containerize
multi-group cross section data. We recommend using
<a class="reference external" href="http://pandas.pydata.org/">Pandas</a> &gt;v0.15.0 or later since OpenMC&#8217;s
Python API leverages the multi-indexing feature included in the most
recent releases of <a class="reference external" href="http://pandas.pydata.org/">Pandas</a>.</p>
<div class="section" id="introduction-to-multi-group-cross-sections-mgxs">
<h1>Introduction to Multi-Group Cross Sections (MGXS)<a class="headerlink" href="#introduction-to-multi-group-cross-sections-mgxs" title="Permalink to this headline">¶</a></h1>
<p>Many Monte Carlo particle transport codes, including OpenMC, use
continuous-energy nuclear cross section data. However, most
deterministic neutron transport codes use <em>multi-group cross sections</em>
defined over discretized energy bins or <em>energy groups</em>. An example of
U-235&#8217;s continuous-energy fission cross section along with a 16-group
cross section computed for a light water reactor spectrum is displayed
below.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="n">Image</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;images/mgxs.png&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">350</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../../_images/mgxs-part-i-content_3_0.png" src="../../_images/mgxs-part-i-content_3_0.png" />
<p>A variety of tools employing different methodologies have been developed
over the years to compute multi-group cross sections for certain
applications, including NJOY (LANL), MC<span class="math">\(^2\)</span>-3 (ANL), and Serpent
(VTT). The <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> Python module is designed to leverage
OpenMC&#8217;s tally system to calculate multi-group cross sections with
arbitrary energy discretizations for fine-mesh heterogeneous
deterministic neutron transport applications.</p>
<p>Before proceeding to illustrate how one may use the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code>
module, it is worthwhile to define the general equations used to
calculate multi-group cross sections. This is only intended as a brief
overview of the methodology used by <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> - we refer the
interested reader to the large body of literature on the subject for a
more comprehensive understanding of this complex topic.</p>
<div class="section" id="introductory-notation">
<h2>Introductory Notation<a class="headerlink" href="#introductory-notation" title="Permalink to this headline">¶</a></h2>
<p>The continuous real-valued microscopic cross section may be denoted
<span class="math">\(\sigma_{n,x}(\mathbf{r}, E)\)</span> for position vector
<span class="math">\(\mathbf{r}\)</span>, energy <span class="math">\(E\)</span>, nuclide <span class="math">\(n\)</span> and interaction
type <span class="math">\(x\)</span>. Similarly, the scalar neutron flux may be denoted by
<span class="math">\(\Phi(\mathbf{r},E)\)</span> for position <span class="math">\(\mathbf{r}\)</span> and energy
<span class="math">\(E\)</span>. <strong>Note</strong>: Although nuclear cross sections are dependent on
the temperature <span class="math">\(T\)</span> of the interacting medium, the temperature
variable is neglected here for brevity.</p>
</div>
<div class="section" id="spatial-and-energy-discretization">
<h2>Spatial and Energy Discretization<a class="headerlink" href="#spatial-and-energy-discretization" title="Permalink to this headline">¶</a></h2>
<p>The energy domain for critical systems such as thermal reactors spans
more than 10 orders of magnitude of neutron energies from
10<span class="math">\(^{-5}\)</span> - 10<span class="math">\(^7\)</span> eV. The multi-group approximation
discretization divides this energy range into one or more energy groups.
In particular, for <span class="math">\(G\)</span> total groups, we denote an energy group
index <span class="math">\(g\)</span> such that <span class="math">\(g \in \{1, 2, ..., G\}\)</span>. The energy
group indices are defined such that the smaller group the higher the
energy, and vice versa. The integration over neutron energies across a
discrete energy group is commonly referred to as <strong>energy
condensation</strong>.</p>
<p>Multi-group cross sections are computed for discretized spatial zones in
the geometry of interest. The spatial zones may be defined on a
structured and regular fuel assembly or pin cell mesh, an arbitrary
unstructured mesh or the constructive solid geometry used by OpenMC. For
a geometry with <span class="math">\(K\)</span> distinct spatial zones, we designate each
spatial zone an index <span class="math">\(k\)</span> such that
<span class="math">\(k \in \{1, 2, ..., K\}\)</span>. The volume of each spatial zone is
denoted by <span class="math">\(V_{k}\)</span>. The integration over discrete spatial zones is
commonly referred to as <strong>spatial homogenization</strong>.</p>
</div>
<div class="section" id="general-scalar-flux-weighted-mgxs">
<h2>General Scalar-Flux Weighted MGXS<a class="headerlink" href="#general-scalar-flux-weighted-mgxs" title="Permalink to this headline">¶</a></h2>
<p>The multi-group cross sections computed by <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> are defined
as a <em>scalar flux-weighted average</em> of the microscopic cross sections
across each discrete energy group. This formulation is employed in order
to preserve the reaction rates within each energy group and spatial
zone. In particular, spatial homogenization and energy condensation are
used to compute the general multi-group cross section
<span class="math">\(\sigma_{n,x,k,g}\)</span> as follows:</p>
<div class="math">
\[\sigma_{n,x,k,g} = \frac{\int_{E_{g}}^{E_{g-1}}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\sigma_{n,x}(\mathbf{r},E')\Phi(\mathbf{r},E')}{\int_{E_{g}}^{E_{g-1}}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\Phi(\mathbf{r},E')}\]</div>
<p>This scalar flux-weighted average microscopic cross section is computed
by <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> for most multi-group cross sections, including total,
absorption, and fission reaction types. These double integrals are
stochastically computed with OpenMC&#8217;s tally system - in particular,
<a class="reference external" href="https://mit-crpg.github.io/openmc/pythonapi/filter.html">filters</a> on
the energy range and spatial zone (material, cell or universe) define
the bounds of integration for both numerator and denominator.</p>
</div>
<div class="section" id="multi-group-scattering-matrices">
<h2>Multi-Group Scattering Matrices<a class="headerlink" href="#multi-group-scattering-matrices" title="Permalink to this headline">¶</a></h2>
<p>The general multi-group cross section <span class="math">\(\sigma_{n,x,k,g}\)</span> is a
vector of <span class="math">\(G\)</span> values for each energy group <span class="math">\(g\)</span>. The equation
presented above only discretizes the energy of the incoming neutron and
neglects the outgoing energy of the neutron (if any). Hence, this
formulation must be extended to account for the outgoing energy of
neutrons in the discretized scattering matrix cross section used by
deterministic neutron transport codes.</p>
<p>We denote the incoming and outgoing neutron energy groups as <span class="math">\(g\)</span>
and <span class="math">\(g'\)</span> for the microscopic scattering matrix cross section
<span class="math">\(\sigma_{n,s}(\mathbf{r},E)\)</span>. As before, spatial homogenization
and energy condensation are used to find the multi-group scattering
matrix cross section <span class="math">\(\sigma_{n,s,k,g \to g'}\)</span> as follows:</p>
<div class="math">
\[\sigma_{n,s,k,g\rightarrow g'} = \frac{\int_{E_{g'}}^{E_{g'-1}}\mathrm{d}E''\int_{E_{g}}^{E_{g-1}}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\sigma_{n,s}(\mathbf{r},E'\rightarrow E'')\Phi(\mathbf{r},E')}{\int_{E_{g}}^{E_{g-1}}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\Phi(\mathbf{r},E')}\]</div>
<p>This scalar flux-weighted multi-group microscopic scattering matrix is
computed using OpenMC tallies with both energy in and energy out
filters.</p>
</div>
<div class="section" id="multi-group-fission-spectrum">
<h2>Multi-Group Fission Spectrum<a class="headerlink" href="#multi-group-fission-spectrum" title="Permalink to this headline">¶</a></h2>
<p>The energy spectrum of neutrons emitted from fission is denoted by
<span class="math">\(\chi_{n}(\mathbf{r},E' \rightarrow E'')\)</span> for incoming and
outgoing energies <span class="math">\(E'\)</span> and <span class="math">\(E''\)</span>, respectively. Unlike the
multi-group cross sections <span class="math">\(\sigma_{n,x,k,g}\)</span> considered up to
this point, the fission spectrum is a probability distribution and must
sum to unity. The outgoing energy is typically much less dependent on
the incoming energy for fission than for scattering interactions. As a
result, it is common practice to integrate over the incoming neutron
energy when computing the multi-group fission spectrum. The fission
spectrum may be simplified as <span class="math">\(\chi_{n}(\mathbf{r},E)\)</span> with
outgoing energy <span class="math">\(E\)</span>.</p>
<p>Unlike the multi-group cross sections defined up to this point, the
multi-group fission spectrum is weighted by the fission production rate
rather than the scalar flux. This formulation is intended to preserve
the total fission production rate in the multi-group deterministic
calculation. In order to mathematically define the multi-group fission
spectrum, we denote the microscopic fission cross section as
<span class="math">\(\sigma_{n,f}(\mathbf{r},E)\)</span> and the average number of neutrons
emitted from fission interactions with nuclide <span class="math">\(n\)</span> as
<span class="math">\(\nu_{n}(\mathbf{r},E)\)</span>. The multi-group fission spectrum
<span class="math">\(\chi_{n,k,g}\)</span> is then the probability of fission neutrons emitted
into energy group <span class="math">\(g\)</span>.</p>
<p>Similar to before, spatial homogenization and energy condensation are
used to find the multi-group fission spectrum <span class="math">\(\chi_{n,k,g}\)</span> as
follows:</p>
<div class="math">
\[\chi_{n,k,g'} = \frac{\int_{E_{g'}}^{E_{g'-1}}\mathrm{d}E''\int_{0}^{\infty}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\chi_{n}(\mathbf{r},E'\rightarrow E'')\nu_{n}(\mathbf{r},E')\sigma_{n,f}(\mathbf{r},E')\Phi(\mathbf{r},E')}{\int_{0}^{\infty}\mathrm{d}E'\int_{\mathbf{r} \in V_{k}}\mathrm{d}\mathbf{r}\nu_{n}(\mathbf{r},E')\sigma_{n,f}(\mathbf{r},E')\Phi(\mathbf{r},E')}\]</div>
<p>The fission production-weighted multi-group fission spectrum is computed
using OpenMC tallies with both energy in and energy out filters.</p>
<p>This concludes our brief overview on the methodology to compute
multi-group cross sections. The following sections detail more
concretely how users may employ the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> module to power
simulation workflows requiring multi-group cross sections for downstream
deterministic calculations.</p>
</div>
</div>
<div class="section" id="generate-input-files">
<h1>Generate Input Files<a class="headerlink" href="#generate-input-files" title="Permalink to this headline">¶</a></h1>
<div class="code python highlight-python"><div class="highlight"><pre>import numpy as np
import matplotlib.pyplot as plt

import openmc
import openmc.mgxs as mgxs

%matplotlib inline
</pre></div>
</div>
<p>First we need to define materials that will be used in the problem.
Before defining a material, we must create nuclides that are used in the
material.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate some Nuclides</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Nuclide</span><span class="p">(</span><span class="s">&#39;H-1&#39;</span><span class="p">)</span>
<span class="n">o16</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Nuclide</span><span class="p">(</span><span class="s">&#39;O-16&#39;</span><span class="p">)</span>
<span class="n">u235</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Nuclide</span><span class="p">(</span><span class="s">&#39;U-235&#39;</span><span class="p">)</span>
<span class="n">u238</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Nuclide</span><span class="p">(</span><span class="s">&#39;U-238&#39;</span><span class="p">)</span>
<span class="n">zr90</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Nuclide</span><span class="p">(</span><span class="s">&#39;Zr-90&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>With the nuclides we defined, we will now create a material for the
homogeneous medium.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate a Material and register the Nuclides</span>
<span class="n">inf_medium</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Material</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;moderator&#39;</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">set_density</span><span class="p">(</span><span class="s">&#39;g/cc&#39;</span><span class="p">,</span> <span class="mf">5.</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">add_nuclide</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span>  <span class="mf">0.028999667</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">add_nuclide</span><span class="p">(</span><span class="n">o16</span><span class="p">,</span> <span class="mf">0.01450188</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">add_nuclide</span><span class="p">(</span><span class="n">u235</span><span class="p">,</span> <span class="mf">0.000114142</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">add_nuclide</span><span class="p">(</span><span class="n">u238</span><span class="p">,</span> <span class="mf">0.006886019</span><span class="p">)</span>
<span class="n">inf_medium</span><span class="o">.</span><span class="n">add_nuclide</span><span class="p">(</span><span class="n">zr90</span><span class="p">,</span> <span class="mf">0.002116053</span><span class="p">)</span>
</pre></div>
</div>
<p>With our material, we can now create a <code class="docutils literal"><span class="pre">MaterialsFile</span></code> object that can
be exported to an actual XML file.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate a MaterialsFile, register all Materials, and export to XML</span>
<span class="n">materials_file</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">MaterialsFile</span><span class="p">()</span>
<span class="n">materials_file</span><span class="o">.</span><span class="n">default_xs</span> <span class="o">=</span> <span class="s">&#39;71c&#39;</span>
<span class="n">materials_file</span><span class="o">.</span><span class="n">add_material</span><span class="p">(</span><span class="n">inf_medium</span><span class="p">)</span>
<span class="n">materials_file</span><span class="o">.</span><span class="n">export_to_xml</span><span class="p">()</span>
</pre></div>
</div>
<p>Now let&#8217;s move on to the geometry. This problem will be a simple square
cell with reflective boundary conditions to simulate an infinite
homogeneous medium. The first step is to create the outer bounding
surfaces of the problem.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate boundary Planes</span>
<span class="n">min_x</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">XPlane</span><span class="p">(</span><span class="n">boundary_type</span><span class="o">=</span><span class="s">&#39;reflective&#39;</span><span class="p">,</span> <span class="n">x0</span><span class="o">=-</span><span class="mf">0.63</span><span class="p">)</span>
<span class="n">max_x</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">XPlane</span><span class="p">(</span><span class="n">boundary_type</span><span class="o">=</span><span class="s">&#39;reflective&#39;</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mf">0.63</span><span class="p">)</span>
<span class="n">min_y</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">YPlane</span><span class="p">(</span><span class="n">boundary_type</span><span class="o">=</span><span class="s">&#39;reflective&#39;</span><span class="p">,</span> <span class="n">y0</span><span class="o">=-</span><span class="mf">0.63</span><span class="p">)</span>
<span class="n">max_y</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">YPlane</span><span class="p">(</span><span class="n">boundary_type</span><span class="o">=</span><span class="s">&#39;reflective&#39;</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="mf">0.63</span><span class="p">)</span>
</pre></div>
</div>
<p>With the surfaces defined, we can now create a cell that is defined by
intersections of half-spaces created by the surfaces.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate a Cell</span>
<span class="n">cell</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">cell_id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">)</span>

<span class="c"># Register bounding Surfaces with the Cell</span>
<span class="n">cell</span><span class="o">.</span><span class="n">region</span> <span class="o">=</span> <span class="o">+</span><span class="n">min_x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">max_x</span> <span class="o">&amp;</span> <span class="o">+</span><span class="n">min_y</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">max_y</span>

<span class="c"># Fill the Cell with the Material</span>
<span class="n">cell</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">inf_medium</span>
</pre></div>
</div>
<p>OpenMC requires that there is a &#8220;root&#8221; universe. Let us create a root
universe and add our square cell to it.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate Universe</span>
<span class="n">root_universe</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">universe_id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;root universe&#39;</span><span class="p">)</span>
<span class="n">root_universe</span><span class="o">.</span><span class="n">add_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
</pre></div>
</div>
<p>We now must create a geometry that is assigned a root universe, put the
geometry into a <code class="docutils literal"><span class="pre">GeometryFile</span></code> object, and export it to XML.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Create Geometry and set root Universe</span>
<span class="n">openmc_geometry</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Geometry</span><span class="p">()</span>
<span class="n">openmc_geometry</span><span class="o">.</span><span class="n">root_universe</span> <span class="o">=</span> <span class="n">root_universe</span>

<span class="c"># Instantiate a GeometryFile</span>
<span class="n">geometry_file</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">GeometryFile</span><span class="p">()</span>
<span class="n">geometry_file</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">openmc_geometry</span>

<span class="c"># Export to &quot;geometry.xml&quot;</span>
<span class="n">geometry_file</span><span class="o">.</span><span class="n">export_to_xml</span><span class="p">()</span>
</pre></div>
</div>
<p>Next, we must define simulation parameters. In this case, we will use 10
inactive batches and 40 active batches each with 2500 particles.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># OpenMC simulation parameters</span>
<span class="n">batches</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">inactive</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">particles</span> <span class="o">=</span> <span class="mi">2500</span>

<span class="c"># Instantiate a SettingsFile</span>
<span class="n">settings_file</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">SettingsFile</span><span class="p">()</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">batches</span> <span class="o">=</span> <span class="n">batches</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">inactive</span> <span class="o">=</span> <span class="n">inactive</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">particles</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;tallies&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&#39;summary&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.63</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.63</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.63</span><span class="p">,</span> <span class="mf">0.63</span><span class="p">]</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">set_source_space</span><span class="p">(</span><span class="s">&#39;fission&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>

<span class="c"># Export to &quot;settings.xml&quot;</span>
<span class="n">settings_file</span><span class="o">.</span><span class="n">export_to_xml</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we are ready to generate multi-group cross sections! First, let&#8217;s
define a 2-group structure using the built-in <code class="docutils literal"><span class="pre">EnergyGroups</span></code> class.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate a 2-group EnergyGroups object</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">mgxs</span><span class="o">.</span><span class="n">EnergyGroups</span><span class="p">()</span>
<span class="n">groups</span><span class="o">.</span><span class="n">group_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.625e-6</span><span class="p">,</span> <span class="mf">20.</span><span class="p">])</span>
</pre></div>
</div>
<p>We can now use the <code class="docutils literal"><span class="pre">EnergyGroups</span></code> object, along with our previously
created materials and geometry, to instantiate some <code class="docutils literal"><span class="pre">MGXS</span></code> objects
from the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> module. In particular, the following are
subclasses of the generic and abstract <code class="docutils literal"><span class="pre">MGXS</span></code> class:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">TotalXS</span></code></li>
<li><code class="docutils literal"><span class="pre">TransportXS</span></code></li>
<li><code class="docutils literal"><span class="pre">AbsorptionXS</span></code></li>
<li><code class="docutils literal"><span class="pre">CaptureXS</span></code></li>
<li><code class="docutils literal"><span class="pre">FissionXS</span></code></li>
<li><code class="docutils literal"><span class="pre">NuFissionXS</span></code></li>
<li><code class="docutils literal"><span class="pre">ScatterXS</span></code></li>
<li><code class="docutils literal"><span class="pre">NuScatterXS</span></code></li>
<li><code class="docutils literal"><span class="pre">ScatterMatrixXS</span></code></li>
<li><code class="docutils literal"><span class="pre">NuScatterMatrixXS</span></code></li>
<li><code class="docutils literal"><span class="pre">Chi</span></code></li>
</ul>
<p>These classes provide us with an interface to generate the tally inputs
as well as perform post-processing of OpenMC&#8217;s tally data to compute the
respective multi-group cross sections. In this case, let&#8217;s create the
multi-group total, absorption and scattering cross sections with our
2-group structure.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate a few different sections</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">mgxs</span><span class="o">.</span><span class="n">TotalXS</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">domain_type</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">)</span>
<span class="n">absorption</span> <span class="o">=</span> <span class="n">mgxs</span><span class="o">.</span><span class="n">AbsorptionXS</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">domain_type</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">)</span>
<span class="n">scattering</span> <span class="o">=</span> <span class="n">mgxs</span><span class="o">.</span><span class="n">ScatterXS</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">domain_type</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">groups</span><span class="p">)</span>
</pre></div>
</div>
<p>Each multi-group cross section object stores its tallies in a Python
dictionary called <code class="docutils literal"><span class="pre">tallies</span></code>. We can inspect the tallies in the
dictionary for our <code class="docutils literal"><span class="pre">Absorption</span></code> object as follows.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">absorption</span><span class="o">.</span><span class="n">tallies</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>OrderedDict([(&#39;flux&#39;, Tally
    ID             =        10000
    Name           =
    Filters        =
                            cell    [1]
                            energy  [  0.00000000e+00   6.25000000e-07   2.00000000e+01]
    Nuclides       =        total
    Scores         =        [&#39;flux&#39;]
    Estimator      =        tracklength
), (&#39;absorption&#39;, Tally
    ID             =        10001
    Name           =
    Filters        =
                            cell    [1]
                            energy  [  0.00000000e+00   6.25000000e-07   2.00000000e+01]
    Nuclides       =        total
    Scores         =        [&#39;absorption&#39;]
    Estimator      =        tracklength
)])
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">Absorption</span></code> object includes tracklength tallies for the
&#8216;absorption&#8217; and &#8216;flux&#8217; scores in the 2-group structure in cell 1. Now
that each <code class="docutils literal"><span class="pre">MGXS</span></code> object contains the tallies that it needs, we must
add these tallies to a <code class="docutils literal"><span class="pre">TalliesFile</span></code> object to generate the
&#8220;tallies.xml&#8221; input file for OpenMC.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Instantiate an empty TalliesFile</span>
<span class="n">tallies_file</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">TalliesFile</span><span class="p">()</span>

<span class="c"># Add total tallies to the tallies file</span>
<span class="k">for</span> <span class="n">tally</span> <span class="ow">in</span> <span class="n">total</span><span class="o">.</span><span class="n">tallies</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="n">tallies_file</span><span class="o">.</span><span class="n">add_tally</span><span class="p">(</span><span class="n">tally</span><span class="p">)</span>

<span class="c"># Add absorption tallies to the tallies file</span>
<span class="k">for</span> <span class="n">tally</span> <span class="ow">in</span> <span class="n">absorption</span><span class="o">.</span><span class="n">tallies</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="n">tallies_file</span><span class="o">.</span><span class="n">add_tally</span><span class="p">(</span><span class="n">tally</span><span class="p">)</span>

<span class="c"># Add scattering tallies to the tallies file</span>
<span class="k">for</span> <span class="n">tally</span> <span class="ow">in</span> <span class="n">scattering</span><span class="o">.</span><span class="n">tallies</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="n">tallies_file</span><span class="o">.</span><span class="n">add_tally</span><span class="p">(</span><span class="n">tally</span><span class="p">)</span>

<span class="c"># Export to &quot;tallies.xml&quot;</span>
<span class="n">tallies_file</span><span class="o">.</span><span class="n">export_to_xml</span><span class="p">()</span>
</pre></div>
</div>
<p>Now we a have a complete set of inputs, so we can go ahead and run our
simulation.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Run OpenMC</span>
<span class="n">executor</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Executor</span><span class="p">()</span>
<span class="n">executor</span><span class="o">.</span><span class="n">run_simulation</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>       .d88888b.                             888b     d888  .d8888b.
      d88P&quot; &quot;Y88b                            8888b   d8888 d88P  Y88b
      888     888                            88888b.d88888 888    888
      888     888 88888b.   .d88b.  88888b.  888Y88888P888 888
      888     888 888 &quot;88b d8P  Y8b 888 &quot;88b 888 Y888P 888 888
      888     888 888  888 88888888 888  888 888  Y8P  888 888    888
      Y88b. .d88P 888 d88P Y8b.     888  888 888   &quot;   888 Y88b  d88P
       &quot;Y88888P&quot;  88888P&quot;   &quot;Y8888  888  888 888       888  &quot;Y8888P&quot;
__________________888______________________________________________________
                  888
                  888

      Copyright:      2011-2015 Massachusetts Institute of Technology
      License:        http://mit-crpg.github.io/openmc/license.html
      Version:        0.7.0
      Git SHA1:       c4b14a5ef87f004528d35cbf33fef3ed15a386ca
      Date/Time:      2015-12-02 09:11:05
      MPI Processes:  1

 ===========================================================================
 ========================&gt;     INITIALIZATION     &lt;=========================
 ===========================================================================

 Reading settings XML file...
 Reading cross sections XML file...
 Reading geometry XML file...
 Reading materials XML file...
 Reading tallies XML file...
 Building neighboring cells lists for each surface...
 Loading ACE cross section table: 1001.71c
 Loading ACE cross section table: 8016.71c
 Loading ACE cross section table: 92235.71c
 Loading ACE cross section table: 92238.71c
 Loading ACE cross section table: 40090.71c
 Maximum neutron transport energy: 20.0000 MeV for 1001.71c
 Initializing source particles...

 ===========================================================================
 ====================&gt;     K EIGENVALUE SIMULATION     &lt;====================
 ===========================================================================

  Bat./Gen.      k            Average k
  =========   ========   ====================
        1/1    1.19804
        2/1    1.12945
        3/1    1.15573
        4/1    1.13929
        5/1    1.16300
        6/1    1.22117
        7/1    1.19012
        8/1    1.11299
        9/1    1.16066
       10/1    1.12566
       11/1    1.20854
       12/1    1.14691    1.17773 +/- 0.03082
       13/1    1.17204    1.17583 +/- 0.01789
       14/1    1.14148    1.16724 +/- 0.01529
       15/1    1.17272    1.16834 +/- 0.01189
       16/1    1.18575    1.17124 +/- 0.01014
       17/1    1.20498    1.17606 +/- 0.00983
       18/1    1.14754    1.17249 +/- 0.00923
       19/1    1.18141    1.17348 +/- 0.00820
       20/1    1.15074    1.17121 +/- 0.00768
       21/1    1.15914    1.17011 +/- 0.00703
       22/1    1.14586    1.16809 +/- 0.00673
       23/1    1.18999    1.16978 +/- 0.00642
       24/1    1.15101    1.16844 +/- 0.00609
       25/1    1.13791    1.16640 +/- 0.00602
       26/1    1.19791    1.16837 +/- 0.00597
       27/1    1.19818    1.17012 +/- 0.00587
       28/1    1.14160    1.16854 +/- 0.00576
       29/1    1.11487    1.16571 +/- 0.00614
       30/1    1.17538    1.16620 +/- 0.00584
       31/1    1.20210    1.16791 +/- 0.00581
       32/1    1.20078    1.16940 +/- 0.00574
       33/1    1.14624    1.16839 +/- 0.00558
       34/1    1.14618    1.16747 +/- 0.00542
       35/1    1.16866    1.16752 +/- 0.00520
       36/1    1.18565    1.16821 +/- 0.00504
       37/1    1.16824    1.16821 +/- 0.00485
       38/1    1.18299    1.16874 +/- 0.00471
       39/1    1.21418    1.17031 +/- 0.00480
       40/1    1.11167    1.16835 +/- 0.00504
       41/1    1.11545    1.16665 +/- 0.00516
       42/1    1.11114    1.16491 +/- 0.00529
       43/1    1.14227    1.16423 +/- 0.00517
       44/1    1.14104    1.16355 +/- 0.00506
       45/1    1.16756    1.16366 +/- 0.00492
       46/1    1.13065    1.16274 +/- 0.00487
       47/1    1.11251    1.16139 +/- 0.00492
       48/1    1.14731    1.16101 +/- 0.00481
       49/1    1.16691    1.16117 +/- 0.00469
       50/1    1.19679    1.16206 +/- 0.00465
 Creating state point statepoint.50.h5...

 ===========================================================================
 ======================&gt;     SIMULATION FINISHED     &lt;======================
 ===========================================================================


 =======================&gt;     TIMING STATISTICS     &lt;=======================

 Total time for initialization     =  4.1700E-01 seconds
   Reading cross sections          =  8.9000E-02 seconds
 Total time in simulation          =  1.4728E+01 seconds
   Time in transport only          =  1.4712E+01 seconds
   Time in inactive batches        =  1.7890E+00 seconds
   Time in active batches          =  1.2939E+01 seconds
   Time synchronizing fission bank =  5.0000E-03 seconds
     Sampling source sites         =  3.0000E-03 seconds
     SEND/RECV source sites        =  2.0000E-03 seconds
   Time accumulating tallies       =  1.0000E-03 seconds
 Total time for finalization       =  1.0000E-03 seconds
 Total time elapsed                =  1.5155E+01 seconds
 Calculation Rate (inactive)       =  13974.3 neutrons/second
 Calculation Rate (active)         =  7728.57 neutrons/second

 ============================&gt;     RESULTS     &lt;============================

 k-effective (Collision)     =  1.16131 +/-  0.00453
 k-effective (Track-length)  =  1.16206 +/-  0.00465
 k-effective (Absorption)    =  1.16096 +/-  0.00364
 Combined k-effective        =  1.16120 +/-  0.00325
 Leakage Fraction            =  0.00000 +/-  0.00000
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="tally-data-processing">
<h1>Tally Data Processing<a class="headerlink" href="#tally-data-processing" title="Permalink to this headline">¶</a></h1>
<p>Our simulation ran successfully and created statepoint and summary
output files. We begin our analysis by instantiating a <code class="docutils literal"><span class="pre">StatePoint</span></code>
object.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Load the last statepoint file</span>
<span class="n">sp</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">StatePoint</span><span class="p">(</span><span class="s">&#39;statepoint.50.h5&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to the statepoint file, our simulation also created a
summary file which encapsulates information about the materials and
geometry. This is necessary for the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> module to properly
process the tally data. We first create a <code class="docutils literal"><span class="pre">Summary</span></code> object and link it
with the statepoint.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Load the summary file and link it with the statepoint</span>
<span class="n">su</span> <span class="o">=</span> <span class="n">openmc</span><span class="o">.</span><span class="n">Summary</span><span class="p">(</span><span class="s">&#39;summary.h5&#39;</span><span class="p">)</span>
<span class="n">sp</span><span class="o">.</span><span class="n">link_with_summary</span><span class="p">(</span><span class="n">su</span><span class="p">)</span>
</pre></div>
</div>
<p>The statepoint is now ready to be analyzed by our multi-group cross
sections. We simply have to load the tallies from the <code class="docutils literal"><span class="pre">StatePoint</span></code>
into each object as follows and our <code class="docutils literal"><span class="pre">MGXS</span></code> objects will compute the
cross sections for us under-the-hood.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Load the tallies from the statepoint into each MGXS object</span>
<span class="n">total</span><span class="o">.</span><span class="n">load_from_statepoint</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="n">absorption</span><span class="o">.</span><span class="n">load_from_statepoint</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
<span class="n">scattering</span><span class="o">.</span><span class="n">load_from_statepoint</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
<p>Voila! Our multi-group cross sections are now ready to rock &#8216;n roll!</p>
</div>
<div class="section" id="extracting-and-storing-mgxs-data">
<h1>Extracting and Storing MGXS Data<a class="headerlink" href="#extracting-and-storing-mgxs-data" title="Permalink to this headline">¶</a></h1>
<p>Let&#8217;s first inspect our total cross section by printing it to the
screen.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">total</span><span class="o">.</span><span class="n">print_xs</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Multi-Group XS
    Reaction Type  =        total
    Domain Type    =        cell
    Domain ID      =        1
    Cross Sections [cm^-1]:
            Group 1 [6.25e-07   - 20.0      MeV]:   6.81e-01 +/- 1.88e-01%
            Group 2 [0.0        - 6.25e-07  MeV]:   1.40e+00 +/- 5.91e-01%
</pre></div>
</div>
<p>Since the <code class="docutils literal"><span class="pre">openmc.mgxs</span></code> module uses <a class="reference external" href="https://mit-crpg.github.io/openmc/pythonapi/examples/tally-arithmetic.html">tally
arithmetic</a>
under-the-hood, the cross section is stored as a &#8220;derived&#8221; <code class="docutils literal"><span class="pre">Tally</span></code>
object. This means that it can be queried and manipulated using all of
the same methods supported for the <code class="docutils literal"><span class="pre">Tally</span></code> class in the OpenMC Python
API. For example, we can construct a
<a class="reference external" href="http://pandas.pydata.org/">Pandas</a> <code class="docutils literal"><span class="pre">DataFrame</span></code> of the multi-group
cross section data.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">df</span> <span class="o">=</span> <span class="n">scattering</span><span class="o">.</span><span class="n">get_pandas_dataframe</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cell</th>
      <th>group in</th>
      <th>nuclide</th>
      <th>mean</th>
      <th>std. dev.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>total</td>
      <td>0.668323</td>
      <td>0.001264</td>
    </tr>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>2</td>
      <td>total</td>
      <td>1.293258</td>
      <td>0.007624</td>
    </tr>
  </tbody>
</table>
</div><p>Each multi-group cross section object can be easily exported to a
variety of file formats, including CSV, Excel, and LaTeX for storage or
data processing.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">absorption</span><span class="o">.</span><span class="n">export_xs_data</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;absorption-xs&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;excel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The following code snippet shows how to export all three <code class="docutils literal"><span class="pre">MGXS</span></code> to the
same HDF5 binary data store.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">total</span><span class="o">.</span><span class="n">build_hdf5_store</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;mgxs&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">absorption</span><span class="o">.</span><span class="n">build_hdf5_store</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;mgxs&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">scattering</span><span class="o">.</span><span class="n">build_hdf5_store</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;mgxs&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="comparing-mgxs-with-tally-arithmetic">
<h1>Comparing MGXS with Tally Arithmetic<a class="headerlink" href="#comparing-mgxs-with-tally-arithmetic" title="Permalink to this headline">¶</a></h1>
<p>Finally, we illustrate how one can leverage OpenMC&#8217;s <a class="reference external" href="https://mit-crpg.github.io/openmc/pythonapi/examples/tally-arithmetic.html">tally
arithmetic</a>
data processing feature with <code class="docutils literal"><span class="pre">MGXS</span></code> objects. The <code class="docutils literal"><span class="pre">openmc.mgxs</span></code>
module uses tally arithmetic to compute multi-group cross sections with
automated uncertainty propagation. Each <code class="docutils literal"><span class="pre">MGXS</span></code> object includes an
<code class="docutils literal"><span class="pre">xs_tally</span></code> attribute which is a &#8220;derived&#8221; <code class="docutils literal"><span class="pre">Tally</span></code> based on the
tallies needed to compute the cross section type of interest. These
derived tallies can be used in subsequent tally arithmetic operations.
For example, we can use tally artithmetic to confirm that the
<code class="docutils literal"><span class="pre">TotalXS</span></code> is equal to the sum of the <code class="docutils literal"><span class="pre">AbsorptionXS</span></code> and
<code class="docutils literal"><span class="pre">ScatterXS</span></code> objects.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Use tally arithmetic to compute the difference between the total, absorption and scattering</span>
<span class="n">difference</span> <span class="o">=</span> <span class="n">total</span><span class="o">.</span><span class="n">xs_tally</span> <span class="o">-</span> <span class="n">absorption</span><span class="o">.</span><span class="n">xs_tally</span> <span class="o">-</span> <span class="n">scattering</span><span class="o">.</span><span class="n">xs_tally</span>

<span class="c"># The difference is a derived tally which can generate Pandas DataFrames for inspection</span>
<span class="n">difference</span><span class="o">.</span><span class="n">get_pandas_dataframe</span><span class="p">()</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cell</th>
      <th>energy [MeV]</th>
      <th>nuclide</th>
      <th>score</th>
      <th>mean</th>
      <th>std. dev.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>(0.0e+00 - 6.3e-07)</td>
      <td>total</td>
      <td>(((total / flux) - (absorption / flux)) - (sca...</td>
      <td>4.884981e-15</td>
      <td>0.011274</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>(6.3e-07 - 2.0e+01)</td>
      <td>total</td>
      <td>(((total / flux) - (absorption / flux)) - (sca...</td>
      <td>1.221245e-15</td>
      <td>0.001802</td>
    </tr>
  </tbody>
</table>
</div><p>Similarly, we can use tally arithmetic to compute the ratio of
<code class="docutils literal"><span class="pre">AbsorptionXS</span></code> and <code class="docutils literal"><span class="pre">ScatterXS</span></code> to the <code class="docutils literal"><span class="pre">TotalXS</span></code>.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Use tally arithmetic to compute the absorption-to-total MGXS ratio</span>
<span class="n">absorption_to_total</span> <span class="o">=</span> <span class="n">absorption</span><span class="o">.</span><span class="n">xs_tally</span> <span class="o">/</span> <span class="n">total</span><span class="o">.</span><span class="n">xs_tally</span>

<span class="c"># The absorption-to-total ratio is a derived tally which can generate Pandas DataFrames for inspection</span>
<span class="n">absorption_to_total</span><span class="o">.</span><span class="n">get_pandas_dataframe</span><span class="p">()</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cell</th>
      <th>energy [MeV]</th>
      <th>nuclide</th>
      <th>score</th>
      <th>mean</th>
      <th>std. dev.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>(0.0e+00 - 6.3e-07)</td>
      <td>total</td>
      <td>((absorption / flux) / (total / flux))</td>
      <td>0.076219</td>
      <td>0.000651</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>(6.3e-07 - 2.0e+01)</td>
      <td>total</td>
      <td>((absorption / flux) / (total / flux))</td>
      <td>0.019319</td>
      <td>0.000086</td>
    </tr>
  </tbody>
</table>
</div><div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Use tally arithmetic to compute the scattering-to-total MGXS ratio</span>
<span class="n">scattering_to_total</span> <span class="o">=</span> <span class="n">scattering</span><span class="o">.</span><span class="n">xs_tally</span> <span class="o">/</span> <span class="n">total</span><span class="o">.</span><span class="n">xs_tally</span>

<span class="c"># The scattering-to-total ratio is a derived tally which can generate Pandas DataFrames for inspection</span>
<span class="n">scattering_to_total</span><span class="o">.</span><span class="n">get_pandas_dataframe</span><span class="p">()</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cell</th>
      <th>energy [MeV]</th>
      <th>nuclide</th>
      <th>score</th>
      <th>mean</th>
      <th>std. dev.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>(0.0e+00 - 6.3e-07)</td>
      <td>total</td>
      <td>((scatter / flux) / (total / flux))</td>
      <td>0.923781</td>
      <td>0.007714</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>(6.3e-07 - 2.0e+01)</td>
      <td>total</td>
      <td>((scatter / flux) / (total / flux))</td>
      <td>0.980681</td>
      <td>0.002617</td>
    </tr>
  </tbody>
</table>
</div><p>Lastly, we sum the derived scatter-to-total and absorption-to-total
ratios to confirm that they sum to unity.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Use tally arithmetic to ensure that the absorption- and scattering-to-total MGXS ratios sum to unity</span>
<span class="n">sum_ratio</span> <span class="o">=</span> <span class="n">absorption_to_total</span> <span class="o">+</span> <span class="n">scattering_to_total</span>

<span class="c"># The scattering-to-total ratio is a derived tally which can generate Pandas DataFrames for inspection</span>
<span class="n">sum_ratio</span><span class="o">.</span><span class="n">get_pandas_dataframe</span><span class="p">()</span>
</pre></div>
</div>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>cell</th>
      <th>energy [MeV]</th>
      <th>nuclide</th>
      <th>score</th>
      <th>mean</th>
      <th>std. dev.</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>(0.0e+00 - 6.3e-07)</td>
      <td>total</td>
      <td>(((absorption / flux) / (total / flux)) + ((sc...</td>
      <td>1</td>
      <td>0.007741</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>(6.3e-07 - 2.0e+01)</td>
      <td>total</td>
      <td>(((absorption / flux) / (total / flux)) + ((sc...</td>
      <td>1</td>
      <td>0.002619</td>
    </tr>
  </tbody>
</table>
</div></div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../index.html">Contents</a>
        </p>

      </div>


    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2015, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>