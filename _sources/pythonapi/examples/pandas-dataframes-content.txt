
This notebook demonstrates how systematic analysis of tally scores is
possible using Pandas dataframes. A dataframe can be automatically
generated using the ``Tally.get_pandas_dataframe(...)`` method.
Furthermore, by linking the tally data in a statepoint file with
geometry and material information from a summary file, the dataframe can
be shown with user-supplied labels.

**Note:** that this Notebook was created using the latest Pandas
v0.16.1. Everything in the Notebook will wun with older versions of
Pandas, but the multi-indexing option in >v0.15.0 makes the tables look
prettier.

.. code:: python

    import glob
    from IPython.display import Image
    import matplotlib.pylab as pylab
    import scipy.stats
    import numpy as np
    
    import openmc
    from openmc.statepoint import StatePoint
    from openmc.summary import Summary
    
    %matplotlib inline

Generate Input Files
--------------------

First we need to define materials that will be used in the problem.
Before defining a material, we must create nuclides that are used in the
material.

.. code:: python

    # Instantiate some Nuclides
    h1 = openmc.Nuclide('H-1')
    b10 = openmc.Nuclide('B-10')
    o16 = openmc.Nuclide('O-16')
    u235 = openmc.Nuclide('U-235')
    u238 = openmc.Nuclide('U-238')
    zr90 = openmc.Nuclide('Zr-90')

With the nuclides we defined, we will now create three materials for the
fuel, water, and cladding of the fuel pin.

.. code:: python

    # 1.6 enriched fuel
    fuel = openmc.Material(name='1.6% Fuel')
    fuel.set_density('g/cm3', 10.31341)
    fuel.add_nuclide(u235, 3.7503e-4)
    fuel.add_nuclide(u238, 2.2625e-2)
    fuel.add_nuclide(o16, 4.6007e-2)
    
    # borated water
    water = openmc.Material(name='Borated Water')
    water.set_density('g/cm3', 0.740582)
    water.add_nuclide(h1, 4.9457e-2)
    water.add_nuclide(o16, 2.4732e-2)
    water.add_nuclide(b10, 8.0042e-6)
    
    # zircaloy
    zircaloy = openmc.Material(name='Zircaloy')
    zircaloy.set_density('g/cm3', 6.55)
    zircaloy.add_nuclide(zr90, 7.2758e-3)

With our three materials, we can now create a materials file object that
can be exported to an actual XML file.

.. code:: python

    # Instantiate a MaterialsFile, add Materials
    materials_file = openmc.MaterialsFile()
    materials_file.add_material(fuel)
    materials_file.add_material(water)
    materials_file.add_material(zircaloy)
    materials_file.default_xs = '71c'
    
    # Export to "materials.xml"
    materials_file.export_to_xml()

Now let's move on to the geometry. This problem will be a square array
of fuel pins for which we can use OpenMC's lattice/universe feature. The
basic universe will have three regions for the fuel, the clad, and the
surrounding coolant. The first step is to create the bounding surfaces
for fuel and clad, as well as the outer bounding surfaces of the
problem.

.. code:: python

    # Create cylinders for the fuel and clad
    fuel_outer_radius = openmc.ZCylinder(x0=0.0, y0=0.0, R=0.39218)
    clad_outer_radius = openmc.ZCylinder(x0=0.0, y0=0.0, R=0.45720)
    
    # Create boundary planes to surround the geometry
    # Use both reflective and vacuum boundaries to make life interesting
    min_x = openmc.XPlane(x0=-10.71, boundary_type='reflective')
    max_x = openmc.XPlane(x0=+10.71, boundary_type='vacuum')
    min_y = openmc.YPlane(y0=-10.71, boundary_type='vacuum')
    max_y = openmc.YPlane(y0=+10.71, boundary_type='reflective')
    min_z = openmc.ZPlane(z0=-10.71, boundary_type='reflective')
    max_z = openmc.ZPlane(z0=+10.71, boundary_type='reflective')

With the surfaces defined, we can now construct a fuel pin cell from
cells that are defined by intersections of half-spaces created by the
surfaces.

.. code:: python

    # Create a Universe to encapsulate a fuel pin
    pin_cell_universe = openmc.Universe(name='1.6% Fuel Pin')
    
    # Create fuel Cell
    fuel_cell = openmc.Cell(name='1.6% Fuel')
    fuel_cell.fill = fuel
    fuel_cell.region = -fuel_outer_radius
    pin_cell_universe.add_cell(fuel_cell)
    
    # Create a clad Cell
    clad_cell = openmc.Cell(name='1.6% Clad')
    clad_cell.fill = zircaloy
    clad_cell.region = +fuel_outer_radius & -clad_outer_radius
    pin_cell_universe.add_cell(clad_cell)
    
    # Create a moderator Cell
    moderator_cell = openmc.Cell(name='1.6% Moderator')
    moderator_cell.fill = water
    moderator_cell.region = +clad_outer_radius
    pin_cell_universe.add_cell(moderator_cell)

Using the pin cell universe, we can construct a 17x17 rectangular
lattice with a 1.26 cm pitch.

.. code:: python

    # Create fuel assembly Lattice
    assembly = openmc.RectLattice(name='1.6% Fuel - 0BA')
    assembly.dimension = (17, 17)
    assembly.pitch = (1.26, 1.26)
    assembly.lower_left = [-1.26 * 17. / 2.0] * 2
    assembly.universes = [[pin_cell_universe] * 17] * 17

OpenMC requires that there is a "root" universe. Let us create a root
cell that is filled by the pin cell universe and then assign it to the
root universe.

.. code:: python

    # Create root Cell
    root_cell = openmc.Cell(name='root cell')
    root_cell.fill = assembly
    
    # Add boundary planes
    root_cell.region = +min_x & -max_x & +min_y & -max_y & +min_z & -max_z
    
    # Create root Universe
    root_universe = openmc.Universe(universe_id=0, name='root universe')
    root_universe.add_cell(root_cell)

We now must create a geometry that is assigned a root universe, put the
geometry into a ``GeometryFile`` object, and export it to XML.

.. code:: python

    # Create Geometry and set root Universe
    geometry = openmc.Geometry()
    geometry.root_universe = root_universe

.. code:: python

    # Instantiate a GeometryFile
    geometry_file = openmc.GeometryFile()
    geometry_file.geometry = geometry
    
    # Export to "geometry.xml"
    geometry_file.export_to_xml()

With the geometry and materials finished, we now just need to define
simulation parameters. In this case, we will use 5 inactive batches and
15 minimum active batches each with 2500 particles. We also tell OpenMC
to turn tally triggers on, which means it will keep running until some
criterion on the uncertainty of tallies is reached.

.. code:: python

    # OpenMC simulation parameters
    min_batches = 20
    max_batches = 200
    inactive = 5
    particles = 2500
    
    # Instantiate a SettingsFile
    settings_file = openmc.SettingsFile()
    settings_file.batches = min_batches
    settings_file.inactive = inactive
    settings_file.particles = particles
    settings_file.output = {'tallies': False, 'summary': True}
    settings_file.trigger_active = True
    settings_file.trigger_max_batches = max_batches
    source_bounds = [-10.71, -10.71, -10, 10.71, 10.71, 10.]
    settings_file.set_source_space('box', source_bounds)
    
    # Export to "settings.xml"
    settings_file.export_to_xml()

Let us also create a plot file that we can use to verify that our pin
cell geometry was created successfully.

.. code:: python

    # Instantiate a Plot
    plot = openmc.Plot(plot_id=1)
    plot.filename = 'materials-xy'
    plot.origin = [0, 0, 0]
    plot.width = [21.5, 21.5]
    plot.pixels = [250, 250]
    plot.color = 'mat'
    
    # Instantiate a PlotsFile, add Plot, and export to "plots.xml"
    plot_file = openmc.PlotsFile()
    plot_file.add_plot(plot)
    plot_file.export_to_xml()

With the plots.xml file, we can now generate and view the plot. OpenMC
outputs plots in .ppm format, which can be converted into a compressed
format like .png with the convert utility.

.. code:: python

    # Run openmc in plotting mode
    executor = openmc.Executor()
    executor.plot_geometry(output=False)




.. parsed-literal::

    0



.. code:: python

    # Convert OpenMC's funky ppm to png
    !convert materials-xy.ppm materials-xy.png
    
    # Display the materials plot inline
    Image(filename='materials-xy.png')




.. image:: pandas-dataframes-content_files/pandas-dataframes-content_26_0.png



As we can see from the plot, we have a nice array of pin cells with
fuel, cladding, and water! Before we run our simulation, we need to tell
the code what we want to tally. The following code shows how to create a
variety of tallies.

.. code:: python

    # Instantiate an empty TalliesFile
    tallies_file = openmc.TalliesFile()
    tallies_file._tallies = []

Instantiate a fission rate mesh Tally

.. code:: python

    # Instantiate a tally Mesh
    mesh = openmc.Mesh(mesh_id=1)
    mesh.type = 'regular'
    mesh.dimension = [17, 17]
    mesh.lower_left = [-10.71, -10.71]
    mesh.width = [1.26, 1.26]
    
    # Instantiate tally Filter
    mesh_filter = openmc.Filter()
    mesh_filter.mesh = mesh
    
    # Instantiate energy Filter
    energy_filter = openmc.Filter()
    energy_filter.type = 'energy'
    energy_filter.bins = np.array([0, 0.625e-6, 20.])
    
    # Instantiate the Tally
    tally = openmc.Tally(name='mesh tally')
    tally.add_filter(mesh_filter)
    tally.add_filter(energy_filter)
    tally.add_score('fission')
    tally.add_score('nu-fission')
    
    # Add mesh and Tally to TalliesFile
    tallies_file.add_mesh(mesh)
    tallies_file.add_tally(tally)

Instantiate a cell Tally with nuclides

.. code:: python

    # Instantiate tally Filter
    cell_filter = openmc.Filter(type='cell', bins=[fuel_cell.id])
    
    # Instantiate the tally
    tally = openmc.Tally(name='cell tally')
    tally.add_filter(cell_filter)
    tally.add_score('scatter-y2')
    tally.add_nuclide(u235)
    tally.add_nuclide(u238)
    
    # Add mesh and tally to TalliesFile
    tallies_file.add_tally(tally)

Create a "distribcell" Tally. The distribcell filter allows us to tally
multiple repeated instances of the same cell throughout the geometry.

.. code:: python

    # Instantiate tally Filter
    distribcell_filter = openmc.Filter(type='distribcell', bins=[moderator_cell.id])
    
    # Instantiate tally Trigger for kicks
    trigger = openmc.Trigger(trigger_type='std_dev', threshold=5e-5)
    trigger.add_score('absorption')
    
    # Instantiate the Tally
    tally = openmc.Tally(name='distribcell tally')
    tally.add_filter(distribcell_filter)
    tally.add_score('absorption')
    tally.add_score('scatter')
    tally.add_trigger(trigger)
    
    # Add mesh and tally to TalliesFile
    tallies_file.add_tally(tally)

.. code:: python

    # Export to "tallies.xml"
    tallies_file.export_to_xml()

Now we a have a complete set of inputs, so we can go ahead and run our
simulation.

.. code:: python

    # Remove old HDF5 (summary, statepoint) files
    !rm statepoint.*
    
    # Run OpenMC with MPI!
    executor.run_simulation()


.. parsed-literal::

    
           .d88888b.                             888b     d888  .d8888b.
          d88P" "Y88b                            8888b   d8888 d88P  Y88b
          888     888                            88888b.d88888 888    888
          888     888 88888b.   .d88b.  88888b.  888Y88888P888 888       
          888     888 888 "88b d8P  Y8b 888 "88b 888 Y888P 888 888       
          888     888 888  888 88888888 888  888 888  Y8P  888 888    888
          Y88b. .d88P 888 d88P Y8b.     888  888 888   "   888 Y88b  d88P
           "Y88888P"  88888P"   "Y8888  888  888 888       888  "Y8888P"
    __________________888______________________________________________________
                      888
                      888
    
          Copyright:      2011-2015 Massachusetts Institute of Technology
          License:        http://mit-crpg.github.io/openmc/license.html
          Version:        0.7.0
          Git SHA1:       21738db07debeabde824c9b955bd3bf0c9a16366
          Date/Time:      2015-10-28 20:55:18
          MPI Processes:  1
    
     ===========================================================================
     ========================>     INITIALIZATION     <=========================
     ===========================================================================
    
     Reading settings XML file...
     Reading cross sections XML file...
     Reading geometry XML file...
     Reading materials XML file...
     Reading tallies XML file...
     Building neighboring cells lists for each surface...
     Loading ACE cross section table: 92235.71c
     Loading ACE cross section table: 92238.71c
     Loading ACE cross section table: 8016.71c
     Loading ACE cross section table: 1001.71c
     Loading ACE cross section table: 5010.71c
     Loading ACE cross section table: 40090.71c
     Maximum neutron transport energy: 20.0000 MeV for 92235.71c
     Initializing source particles...
    
     ===========================================================================
     ====================>     K EIGENVALUE SIMULATION     <====================
     ===========================================================================
    
      Bat./Gen.      k            Average k         
      =========   ========   ====================   
            1/1    0.54958                       
            2/1    0.67628                       
            3/1    0.70618                       
            4/1    0.66601                       
            5/1    0.70876                       
            6/1    0.69708                       
            7/1    0.68623    0.69166 +/- 0.00543
            8/1    0.69159    0.69163 +/- 0.00313
            9/1    0.69908    0.69349 +/- 0.00289
           10/1    0.63865    0.68253 +/- 0.01120
           11/1    0.65439    0.67784 +/- 0.01027
           12/1    0.68518    0.67889 +/- 0.00875
           13/1    0.69507    0.68091 +/- 0.00784
           14/1    0.70129    0.68317 +/- 0.00728
           15/1    0.71336    0.68619 +/- 0.00717
           16/1    0.68725    0.68629 +/- 0.00649
           17/1    0.72579    0.68958 +/- 0.00678
           18/1    0.67149    0.68819 +/- 0.00639
           19/1    0.67771    0.68744 +/- 0.00596
           20/1    0.68035    0.68697 +/- 0.00557
     Triggers unsatisfied, max unc./thresh. is 1.09851 for absorption in tally 10002
     The estimated number of batches is 24
     Creating state point statepoint.020.h5...
           21/1    0.68105    0.68660 +/- 0.00522
           22/1    0.67168    0.68572 +/- 0.00498
           23/1    0.67520    0.68514 +/- 0.00473
           24/1    0.67940    0.68483 +/- 0.00449
     Triggers satisfied for batch 24
     Creating state point statepoint.024.h5...
    
     ===========================================================================
     ======================>     SIMULATION FINISHED     <======================
     ===========================================================================
    
    
     =======================>     TIMING STATISTICS     <=======================
    
     Total time for initialization     =  7.3800E-01 seconds
       Reading cross sections          =  1.5600E-01 seconds
     Total time in simulation          =  1.5998E+01 seconds
       Time in transport only          =  1.5965E+01 seconds
       Time in inactive batches        =  2.3990E+00 seconds
       Time in active batches          =  1.3599E+01 seconds
       Time synchronizing fission bank =  3.0000E-03 seconds
         Sampling source sites         =  1.0000E-03 seconds
         SEND/RECV source sites        =  2.0000E-03 seconds
       Time accumulating tallies       =  3.0000E-03 seconds
     Total time for finalization       =  0.0000E+00 seconds
     Total time elapsed                =  1.6754E+01 seconds
     Calculation Rate (inactive)       =  5210.50 neutrons/second
     Calculation Rate (active)         =  2757.56 neutrons/second
    
     ============================>     RESULTS     <============================
    
     k-effective (Collision)     =  0.68264 +/-  0.00405
     k-effective (Track-length)  =  0.68483 +/-  0.00449
     k-effective (Absorption)    =  0.68225 +/-  0.00336
     Combined k-effective        =  0.68275 +/-  0.00346
     Leakage Fraction            =  0.34345 +/-  0.00167
    




.. parsed-literal::

    0



Tally Data Processing
---------------------

.. code:: python

    # We do not know how many batches were needed to satisfy the 
    # tally trigger(s), so find the statepoint file(s)
    statepoints = glob.glob('statepoint.*.h5')
    
    # Load the last statepoint file
    sp = StatePoint(statepoints[-1])

.. code:: python

    # Load the summary file and link with statepoint
    su = Summary('summary.h5')
    sp.link_with_summary(su)

**Analyze the mesh fission rate tally**

.. code:: python

    # Find the mesh tally with the StatePoint API
    tally = sp.get_tally(name='mesh tally')
    
    # Print a little info about the mesh tally to the screen
    print(tally)


.. parsed-literal::

    Tally
    	ID             =	10000
    	Name           =	mesh tally
    	Filters        =	
                    		mesh	[1]
                    		energy	[  0.00000000e+00   6.25000000e-07   2.00000000e+01]
    	Nuclides       =	total 
    	Scores         =	[u'fission', u'nu-fission']
    	Estimator      =	tracklength
    


Use the new Tally data retrieval API with pure NumPy

.. code:: python

    # Get the relative error for the thermal fission reaction 
    # rates in the four corner pins 
    data = tally.get_values(scores=['fission'], filters=['mesh', 'energy'], \
                            filter_bins=[((1,1),(1,17), (17,1), (17,17)), \
                                        ((0., 0.625e-6),)], value='rel_err')
    print(data)


.. parsed-literal::

    [[[ 0.18257268]]
    
     [[ 0.07111957]]
    
     [[ 0.40880276]]
    
     [[ 0.16407535]]]


.. code:: python

    # Get a pandas dataframe for the mesh tally data
    df = tally.get_pandas_dataframe(nuclides=False)
    
    # Print the first twenty rows in the dataframe
    df.head(20)




.. raw:: html

    <div>
    <table border="1" class="dataframe">
      <thead>
        <tr>
          <th></th>
          <th colspan="3" halign="left">mesh 1</th>
          <th>energy [MeV]</th>
          <th>score</th>
          <th>mean</th>
          <th>std. dev.</th>
        </tr>
        <tr>
          <th></th>
          <th>x</th>
          <th>y</th>
          <th>z</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>fission</td>
          <td>0.000202</td>
          <td>0.000037</td>
        </tr>
        <tr>
          <th>1</th>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>nu-fission</td>
          <td>0.000492</td>
          <td>0.000090</td>
        </tr>
        <tr>
          <th>2</th>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>fission</td>
          <td>0.000076</td>
          <td>0.000004</td>
        </tr>
        <tr>
          <th>3</th>
          <td>1</td>
          <td>1</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>nu-fission</td>
          <td>0.000204</td>
          <td>0.000010</td>
        </tr>
        <tr>
          <th>4</th>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>fission</td>
          <td>0.000375</td>
          <td>0.000039</td>
        </tr>
        <tr>
          <th>5</th>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>nu-fission</td>
          <td>0.000914</td>
          <td>0.000094</td>
        </tr>
        <tr>
          <th>6</th>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>fission</td>
          <td>0.000107</td>
          <td>0.000013</td>
        </tr>
        <tr>
          <th>7</th>
          <td>1</td>
          <td>2</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>nu-fission</td>
          <td>0.000278</td>
          <td>0.000032</td>
        </tr>
        <tr>
          <th>8</th>
          <td>1</td>
          <td>3</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>fission</td>
          <td>0.000564</td>
          <td>0.000056</td>
        </tr>
        <tr>
          <th>9</th>
          <td>1</td>
          <td>3</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>nu-fission</td>
          <td>0.001374</td>
          <td>0.000137</td>
        </tr>
        <tr>
          <th>10</th>
          <td>1</td>
          <td>3</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>fission</td>
          <td>0.000149</td>
          <td>0.000007</td>
        </tr>
        <tr>
          <th>11</th>
          <td>1</td>
          <td>3</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>nu-fission</td>
          <td>0.000388</td>
          <td>0.000018</td>
        </tr>
        <tr>
          <th>12</th>
          <td>1</td>
          <td>4</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>fission</td>
          <td>0.000669</td>
          <td>0.000044</td>
        </tr>
        <tr>
          <th>13</th>
          <td>1</td>
          <td>4</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>nu-fission</td>
          <td>0.001631</td>
          <td>0.000108</td>
        </tr>
        <tr>
          <th>14</th>
          <td>1</td>
          <td>4</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>fission</td>
          <td>0.000165</td>
          <td>0.000011</td>
        </tr>
        <tr>
          <th>15</th>
          <td>1</td>
          <td>4</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>nu-fission</td>
          <td>0.000433</td>
          <td>0.000029</td>
        </tr>
        <tr>
          <th>16</th>
          <td>1</td>
          <td>5</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>fission</td>
          <td>0.000932</td>
          <td>0.000069</td>
        </tr>
        <tr>
          <th>17</th>
          <td>1</td>
          <td>5</td>
          <td>1</td>
          <td>(0.0e+00 - 6.3e-07)</td>
          <td>nu-fission</td>
          <td>0.002270</td>
          <td>0.000168</td>
        </tr>
        <tr>
          <th>18</th>
          <td>1</td>
          <td>5</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>fission</td>
          <td>0.000183</td>
          <td>0.000011</td>
        </tr>
        <tr>
          <th>19</th>
          <td>1</td>
          <td>5</td>
          <td>1</td>
          <td>(6.3e-07 - 2.0e+01)</td>
          <td>nu-fission</td>
          <td>0.000477</td>
          <td>0.000028</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    # Create a boxplot to view the distribution of
    # fission and nu-fission rates in the pins
    bp = df.boxplot(column='mean', by='score')



.. image:: pandas-dataframes-content_files/pandas-dataframes-content_46_0.png


.. code:: python

    # Extract thermal nu-fission rates from pandas
    fiss = df[df['score'] == 'nu-fission']
    fiss = fiss[fiss['energy [MeV]'] == '(0.0e+00 - 6.3e-07)']
    
    # Extract mean and reshape as 2D NumPy arrays
    mean = fiss['mean'].reshape((17,17))
    
    pylab.imshow(mean, interpolation='nearest')
    pylab.title('fission rate')
    pylab.xlabel('x')
    pylab.ylabel('y')
    pylab.colorbar()




.. parsed-literal::

    <matplotlib.colorbar.Colorbar instance at 0x7fdb2d6d5680>




.. image:: pandas-dataframes-content_files/pandas-dataframes-content_47_1.png


**Analyze the cell+nuclides scatter-y2 rate tally**

.. code:: python

    # Find the cell Tally with the StatePoint API
    tally = sp.get_tally(name='cell tally')
    
    # Print a little info about the cell tally to the screen
    print(tally)


.. parsed-literal::

    Tally
    	ID             =	10001
    	Name           =	cell tally
    	Filters        =	
                    		cell	[10000]
    	Nuclides       =	U-235 U-238 
    	Scores         =	[u'scatter-Y0,0', u'scatter-Y1,-1', u'scatter-Y1,0', u'scatter-Y1,1', u'scatter-Y2,-2', u'scatter-Y2,-1', u'scatter-Y2,0', u'scatter-Y2,1', u'scatter-Y2,2']
    	Estimator      =	analog
    


.. code:: python

    # Get a pandas dataframe for the cell tally data
    df = tally.get_pandas_dataframe()
    
    # Print the first twenty rows in the dataframe
    df.head(100)




.. raw:: html

    <div>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>cell</th>
          <th>nuclide</th>
          <th>score</th>
          <th>mean</th>
          <th>std. dev.</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y0,0</td>
          <td>0.037095</td>
          <td>0.001150</td>
        </tr>
        <tr>
          <th>1</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y1,-1</td>
          <td>0.000266</td>
          <td>0.000323</td>
        </tr>
        <tr>
          <th>2</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y1,0</td>
          <td>-0.000417</td>
          <td>0.000274</td>
        </tr>
        <tr>
          <th>3</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y1,1</td>
          <td>-0.000228</td>
          <td>0.000237</td>
        </tr>
        <tr>
          <th>4</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y2,-2</td>
          <td>0.000026</td>
          <td>0.000199</td>
        </tr>
        <tr>
          <th>5</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y2,-1</td>
          <td>-0.000115</td>
          <td>0.000185</td>
        </tr>
        <tr>
          <th>6</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y2,0</td>
          <td>0.000151</td>
          <td>0.000159</td>
        </tr>
        <tr>
          <th>7</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y2,1</td>
          <td>-0.000122</td>
          <td>0.000280</td>
        </tr>
        <tr>
          <th>8</th>
          <td>10000</td>
          <td>U-235</td>
          <td>scatter-Y2,2</td>
          <td>0.000008</td>
          <td>0.000181</td>
        </tr>
        <tr>
          <th>9</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y0,0</td>
          <td>2.328632</td>
          <td>0.013107</td>
        </tr>
        <tr>
          <th>10</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y1,-1</td>
          <td>0.024530</td>
          <td>0.002272</td>
        </tr>
        <tr>
          <th>11</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y1,0</td>
          <td>-0.000059</td>
          <td>0.002804</td>
        </tr>
        <tr>
          <th>12</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y1,1</td>
          <td>-0.027990</td>
          <td>0.002536</td>
        </tr>
        <tr>
          <th>13</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y2,-2</td>
          <td>-0.004861</td>
          <td>0.001575</td>
        </tr>
        <tr>
          <th>14</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y2,-1</td>
          <td>0.000557</td>
          <td>0.002018</td>
        </tr>
        <tr>
          <th>15</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y2,0</td>
          <td>0.006236</td>
          <td>0.001627</td>
        </tr>
        <tr>
          <th>16</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y2,1</td>
          <td>-0.000648</td>
          <td>0.001551</td>
        </tr>
        <tr>
          <th>17</th>
          <td>10000</td>
          <td>U-238</td>
          <td>scatter-Y2,2</td>
          <td>-0.001031</td>
          <td>0.001310</td>
        </tr>
      </tbody>
    </table>
    </div>



Use the new Tally data retrieval API with pure NumPy

.. code:: python

    # Get the standard deviations for two of the spherical harmonic
    # scattering reaction rates 
    data = tally.get_values(scores=['scatter-Y2,2', 'scatter-Y0,0'], 
                            nuclides=['U-238', 'U-235'], value='std_dev')
    print(data)


.. parsed-literal::

    [[[ 0.00131009  0.01310707]
      [ 0.00018089  0.00114976]]]


**Analyze the distribcell tally**

.. code:: python

    # Find the distribcell Tally with the StatePoint API
    tally = sp.get_tally(name='distribcell tally')
    
    # Print a little info about the distribcell tally to the screen
    print(tally)


.. parsed-literal::

    Tally
    	ID             =	10002
    	Name           =	distribcell tally
    	Filters        =	
                    		distribcell	[10002]
    	Nuclides       =	total 
    	Scores         =	[u'absorption', u'scatter']
    	Estimator      =	tracklength
    


Use the new Tally data retrieval API with pure NumPy

.. code:: python

    # Get the relative error for the scattering reaction rates in
    # the first 30 distribcell instances 
    data = tally.get_values(scores=['scatter'], filters=['distribcell'],
                            filter_bins=[(i,) for i in range(10)], value='rel_err')
    print(data)


.. parsed-literal::

    [[[ 0.04537029]]]


Print the distribcell tally dataframe **without** OpenCG info

.. code:: python

    # Get a pandas dataframe for the distribcell tally data
    df = tally.get_pandas_dataframe(nuclides=False)
    
    # Print the last twenty rows in the dataframe
    df.tail(20)




.. raw:: html

    <div>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>distribcell</th>
          <th>score</th>
          <th>mean</th>
          <th>std. dev.</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>558</th>
          <td>279</td>
          <td>absorption</td>
          <td>0.000093</td>
          <td>0.000013</td>
        </tr>
        <tr>
          <th>559</th>
          <td>279</td>
          <td>scatter</td>
          <td>0.013504</td>
          <td>0.000805</td>
        </tr>
        <tr>
          <th>560</th>
          <td>280</td>
          <td>absorption</td>
          <td>0.000084</td>
          <td>0.000010</td>
        </tr>
        <tr>
          <th>561</th>
          <td>280</td>
          <td>scatter</td>
          <td>0.014215</td>
          <td>0.000612</td>
        </tr>
        <tr>
          <th>562</th>
          <td>281</td>
          <td>absorption</td>
          <td>0.000091</td>
          <td>0.000008</td>
        </tr>
        <tr>
          <th>563</th>
          <td>281</td>
          <td>scatter</td>
          <td>0.014545</td>
          <td>0.000590</td>
        </tr>
        <tr>
          <th>564</th>
          <td>282</td>
          <td>absorption</td>
          <td>0.000112</td>
          <td>0.000012</td>
        </tr>
        <tr>
          <th>565</th>
          <td>282</td>
          <td>scatter</td>
          <td>0.016321</td>
          <td>0.000729</td>
        </tr>
        <tr>
          <th>566</th>
          <td>283</td>
          <td>absorption</td>
          <td>0.000092</td>
          <td>0.000007</td>
        </tr>
        <tr>
          <th>567</th>
          <td>283</td>
          <td>scatter</td>
          <td>0.016163</td>
          <td>0.000661</td>
        </tr>
        <tr>
          <th>568</th>
          <td>284</td>
          <td>absorption</td>
          <td>0.000104</td>
          <td>0.000011</td>
        </tr>
        <tr>
          <th>569</th>
          <td>284</td>
          <td>scatter</td>
          <td>0.017384</td>
          <td>0.000599</td>
        </tr>
        <tr>
          <th>570</th>
          <td>285</td>
          <td>absorption</td>
          <td>0.000111</td>
          <td>0.000011</td>
        </tr>
        <tr>
          <th>571</th>
          <td>285</td>
          <td>scatter</td>
          <td>0.018015</td>
          <td>0.000774</td>
        </tr>
        <tr>
          <th>572</th>
          <td>286</td>
          <td>absorption</td>
          <td>0.000125</td>
          <td>0.000012</td>
        </tr>
        <tr>
          <th>573</th>
          <td>286</td>
          <td>scatter</td>
          <td>0.018294</td>
          <td>0.000828</td>
        </tr>
        <tr>
          <th>574</th>
          <td>287</td>
          <td>absorption</td>
          <td>0.000119</td>
          <td>0.000013</td>
        </tr>
        <tr>
          <th>575</th>
          <td>287</td>
          <td>scatter</td>
          <td>0.017483</td>
          <td>0.000757</td>
        </tr>
        <tr>
          <th>576</th>
          <td>288</td>
          <td>absorption</td>
          <td>0.000113</td>
          <td>0.000014</td>
        </tr>
        <tr>
          <th>577</th>
          <td>288</td>
          <td>scatter</td>
          <td>0.018248</td>
          <td>0.000782</td>
        </tr>
      </tbody>
    </table>
    </div>



Print the distribcell tally dataframe **with** OpenCG info

.. code:: python

    # Get a pandas dataframe for the distribcell tally data
    df = tally.get_pandas_dataframe(summary=su, nuclides=False)
    
    # Print the last twenty rows in the dataframe
    df.head(20)




.. raw:: html

    <div>
    <table border="1" class="dataframe">
      <thead>
        <tr>
          <th></th>
          <th colspan="2" halign="left">level 1</th>
          <th colspan="4" halign="left">level 2</th>
          <th colspan="2" halign="left">level 3</th>
          <th>distribcell</th>
          <th>score</th>
          <th>mean</th>
          <th>std. dev.</th>
        </tr>
        <tr>
          <th></th>
          <th>cell</th>
          <th>univ</th>
          <th colspan="4" halign="left">lat</th>
          <th>cell</th>
          <th>univ</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
        <tr>
          <th></th>
          <th>id</th>
          <th>id</th>
          <th>id</th>
          <th>x</th>
          <th>y</th>
          <th>z</th>
          <th>id</th>
          <th>id</th>
          <th></th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>0</td>
          <td>absorption</td>
          <td>0.000123</td>
          <td>0.000012</td>
        </tr>
        <tr>
          <th>1</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>0</td>
          <td>scatter</td>
          <td>0.017805</td>
          <td>0.000808</td>
        </tr>
        <tr>
          <th>2</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>1</td>
          <td>absorption</td>
          <td>0.000217</td>
          <td>0.000020</td>
        </tr>
        <tr>
          <th>3</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>1</td>
          <td>scatter</td>
          <td>0.028867</td>
          <td>0.001263</td>
        </tr>
        <tr>
          <th>4</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>2</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>2</td>
          <td>absorption</td>
          <td>0.000318</td>
          <td>0.000020</td>
        </tr>
        <tr>
          <th>5</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>2</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>2</td>
          <td>scatter</td>
          <td>0.040493</td>
          <td>0.001269</td>
        </tr>
        <tr>
          <th>6</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>3</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>3</td>
          <td>absorption</td>
          <td>0.000386</td>
          <td>0.000018</td>
        </tr>
        <tr>
          <th>7</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>3</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>3</td>
          <td>scatter</td>
          <td>0.048576</td>
          <td>0.001337</td>
        </tr>
        <tr>
          <th>8</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>4</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>4</td>
          <td>absorption</td>
          <td>0.000501</td>
          <td>0.000026</td>
        </tr>
        <tr>
          <th>9</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>4</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>4</td>
          <td>scatter</td>
          <td>0.057063</td>
          <td>0.001715</td>
        </tr>
        <tr>
          <th>10</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>5</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>5</td>
          <td>absorption</td>
          <td>0.000484</td>
          <td>0.000026</td>
        </tr>
        <tr>
          <th>11</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>5</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>5</td>
          <td>scatter</td>
          <td>0.060822</td>
          <td>0.001581</td>
        </tr>
        <tr>
          <th>12</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>6</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>6</td>
          <td>absorption</td>
          <td>0.000532</td>
          <td>0.000039</td>
        </tr>
        <tr>
          <th>13</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>6</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>6</td>
          <td>scatter</td>
          <td>0.069101</td>
          <td>0.002249</td>
        </tr>
        <tr>
          <th>14</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>7</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>7</td>
          <td>absorption</td>
          <td>0.000577</td>
          <td>0.000039</td>
        </tr>
        <tr>
          <th>15</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>7</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>7</td>
          <td>scatter</td>
          <td>0.076722</td>
          <td>0.002335</td>
        </tr>
        <tr>
          <th>16</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>8</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>8</td>
          <td>absorption</td>
          <td>0.000649</td>
          <td>0.000039</td>
        </tr>
        <tr>
          <th>17</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>8</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>8</td>
          <td>scatter</td>
          <td>0.081564</td>
          <td>0.001610</td>
        </tr>
        <tr>
          <th>18</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>9</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>9</td>
          <td>absorption</td>
          <td>0.000680</td>
          <td>0.000032</td>
        </tr>
        <tr>
          <th>19</th>
          <td>10003</td>
          <td>0</td>
          <td>10001</td>
          <td>9</td>
          <td>0</td>
          <td>0</td>
          <td>10002</td>
          <td>10000</td>
          <td>9</td>
          <td>scatter</td>
          <td>0.087715</td>
          <td>0.001959</td>
        </tr>
      </tbody>
    </table>
    </div>



.. code:: python

    # Show summary statistics for absorption distribcell tally data
    absorption = df[df['score'] == 'absorption']
    absorption[['mean', 'std. dev.']].dropna().describe()
    
    # Note that the maximum standard deviation does indeed
    # meet the 5e-4 threshold set by the tally trigger




.. raw:: html

    <div>
    <table border="1" class="dataframe">
      <thead>
        <tr>
          <th></th>
          <th>mean</th>
          <th>std. dev.</th>
        </tr>
        <tr>
          <th></th>
          <th></th>
          <th></th>
        </tr>
        <tr>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>count</th>
          <td>289.000000</td>
          <td>289.000000</td>
        </tr>
        <tr>
          <th>mean</th>
          <td>0.000418</td>
          <td>0.000022</td>
        </tr>
        <tr>
          <th>std</th>
          <td>0.000239</td>
          <td>0.000009</td>
        </tr>
        <tr>
          <th>min</th>
          <td>0.000018</td>
          <td>0.000004</td>
        </tr>
        <tr>
          <th>25%</th>
          <td>0.000202</td>
          <td>0.000015</td>
        </tr>
        <tr>
          <th>50%</th>
          <td>0.000402</td>
          <td>0.000021</td>
        </tr>
        <tr>
          <th>75%</th>
          <td>0.000615</td>
          <td>0.000027</td>
        </tr>
        <tr>
          <th>max</th>
          <td>0.000892</td>
          <td>0.000044</td>
        </tr>
      </tbody>
    </table>
    </div>



Perform a statistical test comparing the tally sample distributions for
two categories of fuel pins.

.. code:: python

    # Extract tally data from pins in the pins divided along y=x diagonal 
    multi_index = ('level 2', 'lat',)
    lower = df[df[multi_index + ('x',)] + df[multi_index + ('y',)] < 16]
    upper = df[df[multi_index + ('x',)] + df[multi_index + ('y',)] > 16]
    lower = lower[lower['score'] == 'absorption']
    upper = upper[upper['score'] == 'absorption']
    
    # Perform non-parametric Mann-Whitney U Test to see if the 
    # absorption rates (may) come from same sampling distribution
    u, p = scipy.stats.mannwhitneyu(lower['mean'], upper['mean'])
    print('Mann-Whitney Test p-value: {0}'.format(p))


.. parsed-literal::

    Mann-Whitney Test p-value: 0.414863173548


Note that the symmetry implied by the y=x diagonal ensures that the two
sampling distributions are identical. Indeed, as illustrated by the test
above, for any reasonable significance level (*e.g.*,
:math:`\alpha`\ =0.05) one would **not reject** the null hypothesis that
the two sampling distributions are identical.

Next, perform the same test but with two groupings of pins which are not
symmetrically identical to one another.

.. code:: python

    # Extract tally data from pins in the pins divided along y=-x diagonal
    multi_index = ('level 2', 'lat',)
    lower = df[df[multi_index + ('x',)] > df[multi_index + ('y',)]]
    upper = df[df[multi_index + ('x',)] < df[multi_index + ('y',)]]
    lower = lower[lower['score'] == 'absorption']
    upper = upper[upper['score'] == 'absorption']
    
    # Perform non-parametric Mann-Whitney U Test to see if the 
    # absorption rates (may) come from same sampling distribution
    u, p = scipy.stats.mannwhitneyu(lower['mean'], upper['mean'])
    print('Mann-Whitney Test p-value: {0}'.format(p))


.. parsed-literal::

    Mann-Whitney Test p-value: 3.28554363741e-42


Note that the asymmetry implied by the y=-x diagonal ensures that the
two sampling distributions are *not* identical. Indeed, as illustrated
by the test above, for any reasonable significance level (*e.g.*,
:math:`\alpha`\ =0.05) one would **reject** the null hypothesis that the
two sampling distributions are identical.

.. code:: python

    # Extract the scatter tally data from pandas
    scatter = df[df['score'] == 'scatter']
    
    scatter['rel. err.'] = scatter['std. dev.'] / scatter['mean']
    
    # Show a scatter plot of the mean vs. the std. dev.
    scatter.plot(kind='scatter', x='mean', y='rel. err.', title='Scattering Rates')


.. parsed-literal::

    /usr/local/lib/python2.7/dist-packages/IPython/kernel/__main__.py:4: SettingWithCopyWarning: 
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead
    
    See the the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy




.. parsed-literal::

    <matplotlib.axes.AxesSubplot at 0x7fdb2d5c3e10>




.. image:: pandas-dataframes-content_files/pandas-dataframes-content_67_2.png


.. code:: python

    # Plot a histogram and kernel density estimate for the scattering rates
    scatter['mean'].plot(kind='hist', bins=25)
    scatter['mean'].plot(kind='kde')
    pylab.title('Scattering Rates')
    pylab.xlabel('Mean')
    pylab.legend(['KDE', 'Histogram'])




.. parsed-literal::

    <matplotlib.legend.Legend at 0x7fdb2d555390>




.. image:: pandas-dataframes-content_files/pandas-dataframes-content_68_1.png

